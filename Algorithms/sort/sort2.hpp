/**
	排序分类：
	1. 内排序是所有的数据读入内存
	2. 外排序：内存中无法保存全部数据，需要进行磁盘访问；
	
	内排序（部分）：
	1. Merge Sort
	2. Quick Sort
	3. Heap Sort
	4. Bucket Sort(桶排序)和 Radix Sort（基数排序）
*/

/*	1. Merge Sort */



/*	2. Quick Sort */


/*	3. Heap	Sort
	priority_queue

 */


/*  4. Bucket Sort
	根据数据大小，放入合适的“桶（容器）”中，在依次从动桶中取出
	，形成有序序列；
	
	复杂度： O（max + n）
*/

// n: 序列长度， 容器中元素为[0,max]之间
void BucketSort(vector<int>& nums, int n, int max){
	// 复制
	vector<int> tmp(nums);

	vector<int> count(max,0);  // 建立桶
	
	int i=0;
	// 计算每个元素在序列中的个数
	for( i = 0; i<n;i++)
		count[nums[i]]++; 
	
	// count[i]存储着下一个元素(i+1)的开始位置
	for(i=1;i<max;i++)
		count[i] = count[i-1] + count[i]; 
	
	// 从后往前计算，不能从前往后，因为只知道起始位置
	// 即当前元素的下一个位置
	for(i=n-1;i>=0;i--){ 
		start = -- count[tmp[i]];  // 当前元素的最后一个位置
		nums[start] = tmp[i];
	}
	
}


/*
	5. 基数排序
	
*/





/*====================================================*/

/**
	二、外排序
	文件分成k块，
	1): 一次读入每个文件块，在内存中排序
	2): 在内存中间里一个最小值堆，读取每块文件的队列头
	3): 弹出堆顶元素，如果元素来自第i块，则从第i块文件中补充一个
		元素到小顶堆，弹出的元素存储到临时数组；
	4): 当临时数组满了，数组写到磁盘，清空数组内存；
	5): 重复3,4,直到文件快读取完毕；
*/



/*=================================================*/


/*例子

	当题目中出现“前k个”，“合并、排序k组数据”或者“数据流”时，
	可以考虑使用heap，动态地维护最大值，最小值信息

*/










