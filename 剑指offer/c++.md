# c++ 常用知识点 记录

## 1. const

#### 作用

- 修饰变量，说明该变量不可以被改变；
- 修饰指针，分为指向常量的指针和指针常量；
- 常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；
- 修饰成员函数，说明该成员函数内不能修改成员变量。

## 2. static
- 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。	
- 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令函数重名，可以将函数定位为 static。
- 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
- 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。


## 3. volatile

```
int volatile i=10;
```
- 该关键词表明被修饰的变量可能会被某些编译器不可未知的原因发生变化，因此阻止编译器对该变量的读取进行优化，每次读取该变量时，都从内存读取
- volatile修饰指针类型与const修饰指针类型的用法类似
- 更改，让编译器对该变量的访问不做过于激进的优化。 
- 一般说来，volatile用在如下的几个地方：(中断程序或者多线程环境) 
	- 中断服务程序中修改的供其它程序检测的变量需要加volatile； 
	- 多任务环境下各任务间共享的标志应该加volatile； 
	- 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；

- volatile指针（多线程中常用）和 const 修饰的类型称为常类型，常类型不允许被更改

## 对比

#### static
- static修饰的变量称为静态变量，存储在全局数据区（CPP中内存分为，堆、栈、自由存储区、全局/静态存储区和常量存储区），生命周期与程序相同，在main之前初始化，在程序结束时销毁。但是能不能访问是由该变量的作用域决定的
- C语言中static修饰的全局变量，只能被当前模块的代码访问
- 类内的static不能在类内进行定义，要在类的作用域内进行定义
- 类的static成员函数不能使用this指针，只能调用static的成员变量或者成员函数
- static全局变量只初始化一次，防止其他模块的调用，static局部变量的地址不会发生变化，下次访问依据前一次的值，static函数只有一份，普通函数每次调用都会维持一份拷贝


#### volatile,const和static
- const与extern一起使用时，就是extern的作用
- const自己使用时，与static作用类似
- const与volatile一起使用时表示变量不允许在本程序被修改，但是可能被其他程序修改

#### extern
- extern “C” 表示让编译器按照C语言的标准编译函数，不产生预处理的中间函数名
- extern 修饰变量或函数表示该变量或函数在其他模块定义


#### const关键字，const与#define的区别 
- const有类型检查，#define没有 
- #define直接进行字符串替换，在程序中会浪费内存空间
- const与#define相比，具有类型判断，同时const声明能够节约内存资源、提高效率




## 4. this指针

- this 指针是一个隐含于每一个成员函数中的特殊指针。它指向正在被该成员函数操作的那个对象。
- 编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，由隐含使用 this 指针。
- 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。
- this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
- this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &this）。



## 5. inline
#### 特点
- 相当于把内联函数里面的内容写在调用内联函数处；
- 相当于不用执行进入函数的步骤，直接执行函数体；
- 相当于宏，却比宏多了类型检查，真正具有函数特性；
- 不能包含循环、递归、switch 等复杂操作；
- 类中除了虚函数的其他函数都会自动隐式地当成内联函数。

#### 编译器处理步骤
- 将 inline 函数体复制到 inline 函数调用点处；
- 为所用 inline 函数中的局部变量分配内存空间；
- 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
- 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。

#### 优点和缺点
优点：
- 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度
- 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。
- 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
- 内联函数在运行时可调试，而宏定义不可以。


缺点：
- 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销
- inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
- 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。




## 6.new/delete malloc/free new[]/delete[] placement new
#### new/delete 和malloc/free
- 属性
	- new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持
- 参数
	- 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸
- 返回类型
	- new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。
- 分配失败
	- new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。
- 自定义类型
	- new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。
	- malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。
- 重载
	- C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。
- 内存区域
	- new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。
	- 那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。

#### new[] / delete []
- new[]专门进行动态数组分配，用delete[]进行销毁。new[]会申请一次分配内存，然后逐一多次调用构造函数，；delete[]会逐一先多次调用析构函数，然后统一销毁一起释放


#### new 、operator new 和 placement new 区别 
(1) new 
- new ：不能被重载，其行为总是一致的。它先调用operator new分配内存，然后调用构造函数初始化那段内存。
- 执行过程：
	- 调用operator new分配内存 ；
	- 调用构造函数生成类对象；
	- 返回相应指针。
	
(2) operator new:
- 只分配所要求的空间，不调用相关对象的构造函数。
- 重载时，返回类型必须声明为void*,第一个参数类型必须为表达要求分配空间的大小（字节），类型为size_t,可以带其它参数
- 要实现不同的内存分配行为，应该重载operator new，而不是new。
- operator new就像operator + 一样，是可以重载的。如果类中没有重载operator new，那么调用的就是全局的::operator new来完成堆的分配。同理，operator new[]、operator delete、operator delete[]也是可以重载的。

(3) placement new
- 只是operator new重载的一个版本。它并不分配内存，只是返回指向已经分配好的某段内存的一个指针。因此不能删除它，但需要调用对象的析构函数
- 也就是说placement new允许你在一个已经分配好的内存中（栈或者堆中）构造一个新的对象。原型中void* p实际上就是指向一个已经分配好的内存缓冲区的的首地址。


## 7. assert
- 断言，是宏，而非函数。assert 宏的原型定义在<assert.h>（C）、<cassert>（C++）中，其作用是如果它的条件返回错误，则终止程序执行


## 8. sizeof 和 strlen
- 类型
	- sizeof是算符，strlen是函数。
- 参数
	- sizeof可以用类型做参数，strlen只能用char*做参数，且必须是以''\0''结尾的。
- 计算时期
	- 大部分编译程序在编译的时候就把sizeof计算过了,是类型或是变量的长度,这就是sizeof(x)可以用来定义数组维数的原因。 
	- strlen的结果要在运行的时候才能计算出来，是用来计算字符串的长度，不是类型占内存的大小。

	
#### sizeof
- sizeof 对数组，得到整个数组所占空间大小。
- sizeof 对指针，得到指针本身所占空间大小。
- sizeof后如果是类型必须加括弧，如果是变量名可以不加括弧。这是因为sizeof是个操作符不是个函数。
- 当适用一个结构类型或变量时， sizeof 返回实际的大小；当适用一静态地空间数组， sizeof 归还全部数组的尺寸；sizeof 操作符不能返回动态地被分派了的数组或外部的数组的尺寸。



## 9. #pragma pack(n)
- 设定结构体、联合以及类成员变量以 n 字节方式对齐
```
#pragma pack(push)  // 保存对齐状态
#pragma pack(4)     // 设定为 4 字节对齐

struct test
{
    char m1;
    double m4;
    int m3;
};

#pragma pack(pop)   // 恢复对齐状态
```

## 10. 位域
- C/C++中以一定区域内的位(bit)为单位来表示的数据成为位域，位域必须指明具体的数目。
- 位域的作用主要是节省内存资源，使数据结构更紧凑。
#### 限制
- 一个位域必须存储在同一个字节中，不能跨两个字节，故位域的长度不能大于一个字节的长度。
- 取地址操作符&不能应用在位域字段上;
- 位域字段不能是类的静态成员;
- 位域字段在内存中的位置是按照从低位向高位的顺序放置的;




# 【参考资料】
- [经典面试题之new和malloc的区别](https://blog.csdn.net/nie19940803/article/details/76358673)
- [C++中的new、operator new与placement new](https://www.cnblogs.com/luxiaoxun/archive/2012/08/10/2631812.html)
- [sizeof与strlen的区别](https://www.cnblogs.com/luori719/p/5218163.html)
- [位域](https://www.cnblogs.com/pure/archive/2013/04/22/3034818.html)

