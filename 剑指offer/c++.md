# c++ 常用知识点 记录


# 一、 关键字和函数
## 1. const

#### 作用

- 修饰变量，说明该变量不可以被改变；
- 修饰指针，分为指向常量的指针和指针常量；
- 常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；
- 修饰成员函数，说明该成员函数内不能修改成员变量。

## 2. static
- 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。	
- 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令函数重名，可以将函数定位为 static。
- 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
- 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。


## 3. volatile

```
int volatile i=10;
```
- 该关键词表明被修饰的变量可能会被某些编译器不可未知的原因发生变化，因此阻止编译器对该变量的读取进行优化，每次读取该变量时，都从内存读取
- volatile修饰指针类型与const修饰指针类型的用法类似
- 更改，让编译器对该变量的访问不做过于激进的优化。 
- 一般说来，volatile用在如下的几个地方：(中断程序或者多线程环境) 
	- 中断服务程序中修改的供其它程序检测的变量需要加volatile； 
	- 多任务环境下各任务间共享的标志应该加volatile； 
	- 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；

- volatile指针（多线程中常用）和 const 修饰的类型称为常类型，常类型不允许被更改

## 对比

#### static
- static修饰的变量称为静态变量，存储在全局数据区（CPP中内存分为，堆、栈、自由存储区、全局/静态存储区和常量存储区），生命周期与程序相同，在main之前初始化，在程序结束时销毁。但是能不能访问是由该变量的作用域决定的
- C语言中static修饰的全局变量，只能被当前模块的代码访问
- 类内的static不能在类内进行定义，要在类的作用域内进行定义
- 类的static成员函数不能使用this指针，只能调用static的成员变量或者成员函数
- static全局变量只初始化一次，防止其他模块的调用，static局部变量的地址不会发生变化，下次访问依据前一次的值，static函数只有一份，普通函数每次调用都会维持一份拷贝


#### volatile,const和static
- const与extern一起使用时，就是extern的作用
- const自己使用时，与static作用类似
- const与volatile一起使用时表示变量不允许在本程序被修改，但是可能被其他程序修改

#### extern
- extern “C” 表示让编译器按照C语言的标准编译函数，不产生预处理的中间函数名
- extern 修饰变量或函数表示该变量或函数在其他模块定义


#### const关键字，const与#define的区别 
- const有类型检查，#define没有 
- #define直接进行字符串替换，在程序中会浪费内存空间
- const与#define相比，具有类型判断，同时const声明能够节约内存资源、提高效率



#### 宏定义和函数有何区别？

- 宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。

- 宏函数属于在结构中插入代码，没有返回值；函数调用具有返回值。

- 宏函数参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。

- 宏函数不要在最后加分号。


#### 宏定义和const区别？

- 宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。

- 宏不检查类型；const会检查数据类型。

- 宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。



#### 宏定义和typedef区别？

- 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。

- 宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。

- 宏不检查类型；typedef会检查数据类型。

- 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。

- 注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。


#### 宏定义和内联函数(inline)区别？
- 在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。

- 内联函数本身是函数，强调函数特性，具有重载等功能。

- 内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。

#### 条件编译#ifdef, #else, #endif作用？
- 可以通过加#define，并通过#ifdef来判断，将某些具体模块包括进要编译的内容。

- 用于子程序前加#define DEBUG用于程序调试。

- 应对硬件的设置（机器类型等）。

- 条件编译功能if也可实现，但条件编译可以减少被编译语句，从而减少目标程序大小。



## 4. this指针

- this 指针是一个隐含于每一个成员函数中的特殊指针。它指向正在被该成员函数操作的那个对象。
- 编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，由隐含使用 this 指针。
- 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。
- this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
- this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &this）。



## 5. inline
#### 特点
- 相当于把内联函数里面的内容写在调用内联函数处；
- 相当于不用执行进入函数的步骤，直接执行函数体；
- 相当于宏，却比宏多了类型检查，真正具有函数特性；
- 不能包含循环、递归、switch 等复杂操作；
- 类中除了虚函数的其他函数都会自动隐式地当成内联函数。

#### 编译器处理步骤
- 将 inline 函数体复制到 inline 函数调用点处；
- 为所用 inline 函数中的局部变量分配内存空间；
- 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
- 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。

#### 优点和缺点
优点：
- 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度
- 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。
- 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
- 内联函数在运行时可调试，而宏定义不可以。


缺点：
- 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销
- inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
- 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。




## 6.new/delete malloc/free new[]/delete[] placement new

#### malloc、calloc、realloc、alloca
- malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。
- calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。
- realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。
- alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。


#### new/delete 和malloc/free

- 属性
	- new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持
- 参数
	- 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸
- 返回类型
	- new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。
- 分配失败
	- new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。
- 自定义类型
	- new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。
	- malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。
- 重载
	- C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。
- 内存区域
	- new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。
	- 那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。

#### new[] / delete []
- new[]专门进行动态数组分配，用delete[]进行销毁。new[]会申请一次分配内存，然后逐一多次调用构造函数，；delete[]会逐一先多次调用析构函数，然后统一销毁一起释放


#### new 、operator new 和 placement new 区别 
(1) new 
- new ：不能被重载，其行为总是一致的。它先调用operator new分配内存，然后调用构造函数初始化那段内存。
- 执行过程：
	- 调用operator new分配内存 ；
	- 调用构造函数生成类对象；
	- 返回相应指针。
	
(2) operator new:
- 只分配所要求的空间，不调用相关对象的构造函数。
- 重载时，返回类型必须声明为void*,第一个参数类型必须为表达要求分配空间的大小（字节），类型为size_t,可以带其它参数
- 要实现不同的内存分配行为，应该重载operator new，而不是new。
- operator new就像operator + 一样，是可以重载的。如果类中没有重载operator new，那么调用的就是全局的::operator new来完成堆的分配。同理，operator new[]、operator delete、operator delete[]也是可以重载的。

(3) placement new
- 只是operator new重载的一个版本。它并不分配内存，只是返回指向已经分配好的某段内存的一个指针。因此不能删除它，但需要调用对象的析构函数
- 也就是说placement new允许你在一个已经分配好的内存中（栈或者堆中）构造一个新的对象。原型中void* p实际上就是指向一个已经分配好的内存缓冲区的的首地址。






## 7. assert
- 断言，是宏，而非函数。assert 宏的原型定义在<assert.h>（C）、<cassert>（C++）中，其作用是如果它的条件返回错误，则终止程序执行


## 8. sizeof 和 strlen
- 类型
	- sizeof是算符，strlen是函数。
- 参数
	- sizeof可以用类型做参数，strlen只能用char*做参数，且必须是以''\0''结尾的。
- 计算时期
	- 大部分编译程序在编译的时候就把sizeof计算过了,是类型或是变量的长度,这就是sizeof(x)可以用来定义数组维数的原因。 
	- strlen的结果要在运行的时候才能计算出来，是用来计算字符串的长度，不是类型占内存的大小。

	
#### sizeof
- sizeof 对数组，得到整个数组所占空间大小。
- sizeof 对指针，得到指针本身所占空间大小。
- sizeof后如果是类型必须加括弧，如果是变量名可以不加括弧。这是因为sizeof是个操作符不是个函数。
- 当适用一个结构类型或变量时， sizeof 返回实际的大小；当适用一静态地空间数组， sizeof 归还全部数组的尺寸；sizeof 操作符不能返回动态地被分派了的数组或外部的数组的尺寸。



## 9. #pragma pack(n)
- 设定结构体、联合以及类成员变量以 n 字节方式对齐
```
#pragma pack(push)  // 保存对齐状态
#pragma pack(4)     // 设定为 4 字节对齐

struct test
{
    char m1;
    double m4;
    int m3;
};

#pragma pack(pop)   // 恢复对齐状态
```

## 10. 位域
- C/C++中以一定区域内的位(bit)为单位来表示的数据成为位域，位域必须指明具体的数目。
- 位域的作用主要是节省内存资源，使数据结构更紧凑。
#### 限制
- 一个位域必须存储在同一个字节中，不能跨两个字节，故位域的长度不能大于一个字节的长度。
- 取地址操作符&不能应用在位域字段上;
- 位域字段不能是类的静态成员;
- 位域字段在内存中的位置是按照从低位向高位的顺序放置的;


## 11. 结构体
#### 结构体内存对齐问题？

- 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。

- 未特殊说明时，按结构体中size最大的成员对齐（若有double成员），按8字节对齐。

- 结构体的默认限定符是public；类是private。



## 12. union
联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：


- 默认访问控制符为 public
- 可以含有构造函数、析构函数
- 不能含有引用类型的成员
- 不能继承自其他类，不能作为基类
- 不能含有虚函数
- 匿名 union 在定义所在作用域可直接访问 union 成员
- 匿名 union 不能包含 protected 成员或 private 成员
- 全局匿名联合必须是静态（static）的



## 13. explicit 
- explicit 修饰的构造函数可用来防止隐式转换

## 14. friend 友元类和友元函数

- 能访问私有成员
- 破坏封装性
- 友元关系不可传递
- 友元关系的单向性
- 友元声明的形式及数量不受限制


## 15. :: 范围解析运算符

- 全局作用域符（`::name`）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间
- 类作用域符（`class::name`）：用于表示指定类型的作用域范围是具体某个类的
- 命名空间作用域符（`namespace::name`）:用于表示指定类型的作用域范围是具体某个命名空间的

## 16.enum 枚举类型
#### 限定作用域的枚举类型
```
enum class open_modes { input, output, append };
```
#### 不限定作用域的枚举类型
```
enum color { red, yellow, green };
enum { floatPrec = 6, doublePrec = 10 };
```
## 17. decltype
- decltype 关键字用于检查实体的声明类型或表达式的类型及值分类。
- `decltype ( expression )`

## 18. 引用
#### 左值引用
- 常规引用，一般表示对象的身份。
#### 指针和引用区别？
- 引用只是别名，不占用具体存储空间，只有声明没有定义；指针是具体变量，需要占用存储空间。

- 引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。

- 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。

- 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。


#### 右值引用
- 右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。

- 右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：

	- 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
	- 能够更简洁明确地定义泛型函数。
	
- [C++ 11 左值，右值，左值引用，右值引用，std::move, std::foward](https://blog.csdn.net/xiaolewennofollow/article/details/52559306)
	
	
	
	

#### 引用折叠

- `X& &`、`X& &&`、`X&& &` 可折叠成 `X&`
- `X&& &&` 可折叠成 `X&&`	
	

## 19. 成员初始化列表

- 更高效：少了一次调用默认构造函数的过程。
- 有些场合必须要用初始化列表：
	- 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
	- 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
	- 调用一个基类的构造函数，而该函数有一组参数。
	- 调用一个数据成员对象的构造函数，而该函数有一组参数。
	
	
#### initializer_list 列表初始化【C++11】

- 用花括号初始化器列表列表初始化一个对象，其中对应构造函数接受一个 std::initializer_list 参数.

<details><summary>initializer_list use</summary>

```c++
#include <iostream>
#include <vector>
#include <initializer_list>
 
template <class T>
struct S {
    std::vector<T> v;
    S(std::initializer_list<T> l) : v(l) {
         std::cout << "constructed with a " << l.size() << "-element list\n";
    }
    void append(std::initializer_list<T> l) {
        v.insert(v.end(), l.begin(), l.end());
    }
    std::pair<const T*, std::size_t> c_arr() const {
        return {&v[0], v.size()};  // 在 return 语句中复制列表初始化
                                   // 这不使用 std::initializer_list
    }
};
 
template <typename T>
void templated_fn(T) {}
 
int main()
{
    S<int> s = {1, 2, 3, 4, 5}; // 复制初始化
    s.append({6, 7, 8});      // 函数调用中的列表初始化
 
    std::cout << "The vector size is now " << s.c_arr().second << " ints:\n";
 
    for (auto n : s.v)
        std::cout << n << ' ';
    std::cout << '\n';
 
    std::cout << "Range-for over brace-init-list: \n";
 
    for (int x : {-1, -2, -3}) // auto 的规则令此带范围 for 工作
        std::cout << x << ' ';
    std::cout << '\n';
 
    auto al = {10, 11, 12};   // auto 的特殊规则
 
    std::cout << "The list bound to auto has size() = " << al.size() << '\n';
 
//    templated_fn({1, 2, 3}); // 编译错误！“ {1, 2, 3} ”不是表达式，
                             // 它无类型，故 T 无法推导
    templated_fn<std::initializer_list<int>>({1, 2, 3}); // OK
    templated_fn<std::vector<int>>({1, 2, 3});           // 也 OK
}
```

</details>


# 二、对象

## 20 面向对象

![](https://camo.githubusercontent.com/47b653e6f0d7813c3cb7bfdeffe67782748474b9/687474703a2f2f696d672e6d792e6373646e2e6e65742f75706c6f6164732f3230313231312f32322f313335333536343532345f363337352e706e67)

- 面向对象三大特征 —— 封装、继承、多态
- 对象存储空间？
	- 非静态成员的数据类型大小之和。


####  封装
- 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
- 关键字：public, protected, friendly, private。不写默认为 friendly。
	- public的变量和函数在类的内部外部都可以访问。
	- protected的变量和函数只能在类的内部和其派生类中访问。
	- private修饰的元素只能在类内访问。
#### 继承
- 基类（父类）——> 派生类（子类）
#### 多态
- 多态，即多种状态，在面向对象语言中，接口的多种不同的实现方式即为多态。
- C++ 多态有两种：静态多态（早绑定）、动态多态（晚绑定）。静态多态是通过函数重载实现的；动态多态是通过虚函数实现的。
- 多态是以封装和继承为基础的。

#### 静态多态（早绑定）
- 函数重载

#### 动态多态（晚绑定）
- 虚函数：用 virtual 修饰成员函数，使其成为虚函数

- 普通函数（非类成员函数）不能是虚函数
- 静态函数（static）不能是虚函数
- 构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）
- 内联函数不能是表现多态性时的虚函数

#### 覆盖、重载和隐藏的区别？

- 覆盖是派生类中重新定义的函数，其函数名、参数列表（个数、类型和顺序）、返回值类型和父类完全相同，只有函数体有区别。派生类虽然继承了基类的同名函数，但用派生类对象调用该函数时会根据对象类型调用相应的函数。覆盖只能发生在类的成员函数中。

- 隐藏是指派生类函数屏蔽了与其同名的函数，这里仅要求基类和派生类函数同名即可。其他状态同覆盖。可以说隐藏比覆盖涵盖的范围更宽泛，毕竟参数不加限定。

- 重载是具有相同函数名但参数列表不同（个数、类型或顺序）的两个函数（不关心返回值），当调用函数时根据传递的参数列表来确定具体调用哪个函数。重载可以是同一个类的成员函数也可以是类外函数。



#### C++空类有哪些成员函数?
- 首先，空类大小为1字节。

- 默认函数有：
	- 构造函数
	- 析构函数
	- 拷贝构造函数
	- 赋值运算符

#### 构造函数能否为虚函数，析构函数呢？
- 析构函数：
	- 析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。
	- 只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。
	- 析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。
- 构造函数：
	- 构造函数不能定义为虚函数，不仅如此，构造函数中还不能调用虚函数。因为那样实际执行的是父类对应的函数，因为自己还没有构造好（构造顺序先基类再派生类）。


#### 构造函数调用顺序，析构函数呢？
- 基类的构造函数：如果有多个基类，先调用纵向上最上层基类构造函数，如果横向继承了多个类，调用顺序为派生表从左到右顺序。

- 成员类对象的构造函数：如果类的变量中包含其他类（类的组合），需要在调用本类构造函数前先调用成员类对象的构造函数，调用顺序遵照在类中被声明的顺序。

- 派生类的构造函数。

- 析构函数与之相反。	
	
#### 拷贝构造函数中深拷贝和浅拷贝区别？
- 深拷贝时，当被拷贝对象存在动态分配的存储空间时，需要先动态申请一块存储空间，然后逐字节拷贝内容。
- 浅拷贝仅仅是拷贝指针字面值。
- 当使用浅拷贝时，如果原来的对象调用析构函数释放掉指针所指向的数据，则会产生空悬指针。因为所指向的内存空间已经被释放了。
	
	
#### 拷贝构造函数和赋值运算符重载的区别？
- 拷贝构造函数是函数，赋值运算符是运算符重载。
- 拷贝构造函数会生成新的类对象，赋值运算符不能。
- 拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。
- 形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现"="的地方都是使用赋值运算符，如下：

- 注：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符

#### 虚函数和纯虚函数区别？

- 虚函数是为了实现动态编联产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。

- 纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。


####  虚函数指针、虚函数表
- 虚指针或虚函数指针是虚函数的实现细节。
- 虚指针指向虚表结构。
- 虚函数表：在程序只读数据段（.rodata section），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。

#### 虚继承
- 虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。
- 底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。
- 实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。


#### 虚继承、虚函数

- 相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）
- 不同之处：
- 虚继承
	- 虚基类依旧存在继承类中，只占用存储空间
	- 虚基类表存储的是虚基类相对直接继承类的偏移
- 虚函数
	- 虚函数不占用存储空间
	- 虚函数表存储的是虚函数地址

#### 类模板是什么？	

- 用于解决多个功能相同、数据类型不同的类需要重复定义的问题。
- 在建立类时候使用template及任意类型标识符T，之后在建立类对象时，会指定实际的类型，这样才会是一个实际的对象。
- 类模板是对一批仅数据成员类型不同的类的抽象，只要为这一批类创建一个类模板，即给出一套程序代码，就可以用来生成具体的类
	
#### 模板类、成员模板、虚函数
- 模板类中可以使用虚函数
- 一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数
	

	
#### 抽象类、接口类、聚合类

- 抽象类：含有纯虚函数的类
- 接口类：仅含有纯虚函数的抽象类
- 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：
	- 所有成员都是 public
	- 没有有定于任何构造函数
	- 没有类内初始化
	- 没有基类，也没有 virtual 函数	

	
#### 构造函数和析构函数调用时机？

- 全局范围中的对象：构造函数在所有函数调用之前执行，在主函数执行完调用析构函数。

- 局部自动对象：建立对象时调用构造函数，函数结束时调用析构函数。

- 动态分配的对象：建立对象时调用构造函数，调用释放时调用析构函数。

- 静态局部变量对象：建立时调用一次构造函数，主函数结束时调用析构函数。
	
	

#### 如何定义一个只能在堆上（栈上）生成对象的类？

- [如何定义一个只能在堆上（栈上）生成对象的类?](https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618)
- 只能在堆上

	- 方法：将析构函数设置为私有

	- 原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。

- 只能在栈上

	- 方法：将 new 和 delete 重载为私有

	- 原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。
	
	

## 21. 智能指针
#### 指针和引用的区别
- 引用是直接访问，指针是间接访问
- 引用是变量的别名，不占用内存空间，指针有自己的内存空间
- 引用是绑定内存的，一个引用被赋值之后不能更改绑定，只能改变引用对象的值

#### 指针与数组千丝万缕的联系

- int b[][3]时++b的步长是3*sizeof(int)
- 数组名称代表着一个数组地址，数组名称是不能改变的，指针可以指向不同的数组
- 数组作为参数传递时，自动退化为对应类型的指针	


#### 智能指针的实现
1. 构造函数中计数初始化为1
2. 拷贝构造函数中计数值加1
3. 赋值运算符中，左边的对象引用计数加1，右边的对象引用计数减1
4. 在赋值和析构函数中，如果计数减1后为0，则调用delete释放对象 

#### share_ptr与weak_ptr，unique_ptr的区别

- weak_ptr 
	- weak_ptr除了对所管理对象的基本访问功能（通过get()函数）外，还有两个常用的功能函数：expired()用于检测所管理的对象是否已经释放；lock()用于获取所管理的对象的强引用指针。使用lock()获得share_ptr之后再对对象进行访问。
	- weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。

- shared_ptr

	- 多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。

	- 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁


- unique_ptr 
只允许基础指针的一个所有者。可以移到新所有者(具有移动语义)，但不会复制或共享（即我们无法得到指向同一个对象的两个unique_ptr） 
使用unique_ptr，可以实现以下功能： 
	1、为动态申请的内存提供异常安全。 
	2、将动态申请内存的所有权传递给某个函数。 
	3、从某个函数返回动态申请内存的所有权。 
	4、在容器中保存指针。 
	5、所有auto_ptr应该具有的（但无法在C++ 03中实现的）功能。	
	
	unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。

	
- unique_ptr 用于取代 auto_ptr
- auto_ptr
	- 被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 std::move 语义，以及其他瑕疵。
- auto_ptr 与 unique_ptr 比较
	- auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了move 语义；
	- auto_ptr 对象不能管理数组（析构调用 delete），unique_ptr 可以管理数组（析构调用 delete[] ）；

	
	
## 22.强制类型转换运算符

#### static_cast
- 用于非多态类型的转换
- 不执行运行时类型检查（转换安全性不如 dynamic_cast）
- 通常用于转换数值数据类型（如 float -> int）
- 可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）
- 向上转换是一种隐式转换。
#### dynamic_cast

- 用于多态类型的转换
- 执行行运行时类型检查
- 只适用于指针或引用
- 对不明确的指针的转换将失败（返回 nullptr），但不引发异常
- 可以在整个类层次结构中移动指针，包括向上转换、向下转换
#### bad_cast

- 由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。

#### const_cast

- 用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）
#### reinterpret_cast

- 用于位的简单重新解释
- 滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。
- 允许将任何指针转换为任何其他指针类型（如 char* 到 int* 或 One_class* 到 Unrelated_class* 之类的转换，但其本身并不安全）
- 也允许将任何整数类型转换为任何指针类型以及反向转换。
- reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。
- reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。


## 23. 运行时类型信息 (RTTI)

- dynamic_cast
	- 用于多态类型的转换
	
- typeid
	- typeid 运算符允许在运行时确定对象的类型
	- type_id 返回一个 type_info 对象的引用
	- 如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数
	- 只能获取对象的实际类型
	
- type_info
	- type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。
	- 头文件：typeinfo



# 三、 STL

## 24. 内存
#### 内存对齐的原则

struct/class/union内存对齐原则有四个： 
- 1).数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在３２位机为４字节, 则要从４的整数倍地址开始存储),基本类型不包括struct/class/uinon。 
- 2).结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部"最宽基本类型成员"的整数倍地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)。 
- 3).收尾工作:结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的"最宽基本类型成员"的整数倍.不足的要补齐.(基本类型不包括struct/class/uinon)。 
- 4).sizeof(union)，以结构里面size最大元素为union的size,因为在某一时刻，union只有一个成员真正存储于该地址

#### c++ 初始化
必须在构造函数初始化式里进行初始化的数据成员有哪些 
- 1.类里面的任何成员变量在定义时是不能初始化的。 
- 2.一般的数据成员可以在构造函数中初始化。 
- 3.const数据成员必须在构造函数的初始化列表中初始化。 
- 4.static要在类的定义外面初始化。 
- 5.数组成员是不能在初始化列表里初始化的。 
- 6.不能给数组指定明显的初始化。 
- **类成员变量的初始化不是按照初始化表的顺序被初始化的，而是按照在类中声明的顺序被初始化的**


#### 内存泄漏定位 
- (1)在windows平台下通过CRT中的库函数进行检测； 
- (2)在可能泄漏的调用前后生成块的快照，比较前后的状态，定位泄漏的位置 
- (3)Linux下通过工具valgrind检测



## 25.常用C库函数实现
#### strcpy

```c++
char* strcpy(char* dst, const char* src){
	assert((dst != NULL && (src != NULL));
	char* tmp = dst;
	
	while((*dst++ = *src++) != '\0');
	return tmp;
}

```
- 考虑重叠

```c++
char* strcpy(char* dst, const char* src){
	assert(dst != NULL && src != NULL);
	char* ret = dst;
	my_memecpy(dst, src, strlen(src)+1);
	return ret;
}

char* my_memecpy(char *dst, char *src , int cnt){
	assert( dst != NULL && src != NULL );
	char *ret = dst;
	if(dst >=src && dst <= src + cnt-1)
	{
		dst = dst + cnt-1;
		src = src + cnt -1;
		while(cnt -- )
			*dst-- = *src--;
	}else{
	while(cnt--)
		*dst++ = *src++;
	}
	return ret;
	
}


```
#### strncpy

```c++
char* strncpy(char *dst, const char *src, size_t n){
	char *ret = dst;
	size_t i=0;
	while(n >0 && *src != '\0')
	{
		*dst++ = *src++;
		n--;
	}
	while(n-->0)
		*dst++ = '\0';
	return ret;
}


```


#### strcat
- 把src所指字符串添加到dest结尾处(覆盖dest结尾处的'\0')。
- src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。

```c++
char* strcat(char* dst, const char* src){

	char* ret = dst;
	while(*dst++ != '\0');
	while(*src != '\0')
		*dst++ = *src++;
	*dst = '\0';
	return ret;

}
```


#### strncat

```c++
char* strncat (char *dst, const char* src , size_t n){
	char* ret = dst;
	size_t i, j;
	for(j=0;dst[j] != '\0';++j);
	for(i=0;i<n && src[i] != '0';)
	{
		dst[j++] = src[i++]; 
	}
	for(;i<n;i++)dst[j] = '\0';
	return ret;
}

```

#### strlen 


```c++
sizt_t strlen(const char* s)
{
	assert(str != NULL);
    const char *eos = str;

    while( *eos++ ) ; // eos 为'\0'后面一个地址

    return( eos - str - 1 );
	
	
}

```


## 26. STL六大组件
- 容器 container
- 算法	algorithm
- 迭代器 Iterator
- 仿函数 Functions
	- 行为类函数，可作为算法的某种策略，从实现角度看，仿函数是一种重载了operator()的class或class template。一般函数指针可视为狭义的仿函数。
- 配接器 Adapter
	- 一种用来修饰容器或者仿函数或迭代器接口的东西。比如queue和stack，看着像容器，其实就是deque包了一层皮。
- 配置器 Allocator
	- 负责空间配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放额class template。
	

#### STL常用的容器有哪些以及各自的特点是什么?
1. vector:底层数据结构为数组 ，支持快速随机访问。
2. list:底层数据结构为双向链表，支持快速增删。
3. deque:底层数据结构为一个中央控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问。
4. stack:底层一般用23实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时
5. queue:底层一般用23实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）
6. priority_queue:的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现
7. set:底层数据结构为红黑树，有序，不重复。
8. multiset:底层数据结构为红黑树，有序，可重复。 
9. map:底层数据结构为红黑树，有序，不重复。
10. multimap:底层数据结构为红黑树，有序，可重复。
11. hash_set:﻿﻿﻿﻿底层数据结构为hash表，无序，不重复。
12. hash_multiset:底层数据结构为hash表，无序，可重复 。
13. hash_map :﻿﻿﻿﻿底层数据结构为hash表，无序，不重复。
14. hash_multimap:底层数据结构为hash表，无序，可重复。 。






	

## 27. STL 容器 vector

#### emplace_back 和 push_back
- [实战c++中的vector系列--知道emplace_back为何优于push_back吗？](https://blog.csdn.net/wangshubo1989/article/details/50357549)
- 添加一个新元素到结束的容器。该元件是构成在就地，即没有复制或移动操作进行。
- emplace_back 传递是容器中的T的参数，直接在vector中的空间中调用构造函数；
- push_back 传递的是T的实例，需要复制或者移动操作；

#### 当vector的内存用完了，它是如何动态扩展内存的？它是怎么释放内存的？用clear可以释放掉内存吗？是不是线程安全的？
- vector内存用完了，会以当前size大小重新申请2*size的内存，然后把原来的元素复制过去，把新元素插上，然后释放原来的内存。
- 一般我们释放vector里的元素使用clear，其实它不能释放内存，要想释放内存要使用swap;
- 引用《effective stl》的第十二条：当涉及 STL容器和线程安全性时，你可以指望一个 STL库允许多个线程同时读一个容器，以及多个线程对不同的容器做写入操作。你不能指望 STL库会把你从手工同步控制中解脱出来，而且你不能依赖于任何线程支持。必须自己去写多线程安全措施。


#### vector每次insert或erase之后，以前保存的iterator会不会失效？
- 理论上会失效，理论上每次insert或者erase之后，所有的迭代器就重新计算的，所以都可以看作会失效，原则上是不能使用过期的内存
但是vector一般底层是用数组实现的，我们仔细考虑数组的特性，不难得出另一个结论:
- insert时，假设insert位置在p，分两种情况：
	- 容器还有空余空间，不重新分配内存，那么p之前的迭代器都有效，p之后的迭代器都失效
	- 容器重新分配了内存，那么p之后的迭代器都无效咯
- erase时，假设erase位置在p，则p之前的迭代器都有效并且p指向下一个元素位置（如果之前p在尾巴上，则p指向无效尾end），p之后的迭代器都无效


#### vector中erase方法与algorithn中的remove方法区别

- vector中erase方法真正删除了元素，迭代器不能访问了
- remove只是简单地将元素移到了容器的最后面，迭代器还是可以访问到。因为algorithm通过迭代器进行操作，不知道容器的内部结构，所以无法进行真正的删除。




## 28. List
- 环状的双向链表，尾部有空白节点（为满足左闭右开），节点不保证连续存在，迭代器不失效。
- 内部有一个 last 迭代器指向尾端空白节点（其 next 为 begin 迭代器）。 
- List 不能使用算法 sort（只接受随机存取迭代器），它有自己内置的 sort。
- [STL库list::sort()实现深度解析](https://www.cnblogs.com/avota/archive/2016/04/13/5388865.html)

#### vector和list的区别
- vector和数组类似，拥有连续的内存空间，支持随机的存取，在中间进行元素的插入和删除的操作时间复杂度是O(n)

- list是由双向链表实现的，只能通过数组指针来进行数据访问，遍历中间的元素，时间的复杂度是O(n).


#### vector插入删除和list有什么区别？
- vector插入和删除数据，需要对现有数据进行复制移动，如果vector存储的对象很大或者构造函数很复杂，则开销较大，如果是简单的小数据，效率优于list。
- list插入和删除数据，需要对现有数据进行遍历，但在首部插入数据，效率很高。

#### 什么情况下用vector，什么情况下用list。
- vector可以随机存储元素（即可以通过公式直接计算出元素地址，而不需要挨个查找），但在非尾部插入删除数据时，效率很低，适合对象简单，对象数量变化不大，随机访问频繁。
- list不支持随机存储，适用于对象大，对象数量变化频繁，插入和删除频繁。




## 29. deque
双向开口的连续线性空间，没有容量概念，动态地以分段连续空间组合而成， 随时可增加新空间并链接起来（伪连续，负担落在迭代器身上） 
使用中控器 map，存的指针，指向实际存储块 
迭代器失效： 
1. 在deque容器首部或者尾部插入元素不会使得任何迭代器失效； 
2. 在其首部或尾部删除元素则只会使指向被删除元素的迭代器失效； 
3. 在deque容器的任何其他位置的插入和删除操作将使指向该容器元素的所有迭代器失效。

注意：除非必要，我们尽可能选择使用vector而非deque，因为deque的迭代器比vector迭代器复杂很多。对deque排序，为了提高效率，可先将deque复制到一个vector上排序，然后再复制回deque。

deque采用一块map（不是STL的map容器）作为主控，其为一小块连续空间，其中每个元素都是指针，指向另一段较大的连续空间（缓冲区）。
deque的迭代器包含4个内容：
1. cur：迭代器当前所指元素
2. first：此迭代器所指的缓冲区的头。
3. last：缓冲区尾。
4. node：指向管控中心。


## 30. stack 和 queue
- 都是以list或者 deque作为底层容器
- stack没有迭代器
- queue没有迭代器
- 不用 vector 的原因应该是容量大小有限制，扩容耗时



## 31. priority_queue 和 heap

- 使用最大堆实现，用 vector 存储。
- 没有迭代器




## 32. 红黑树和set 、 map ,multiset\ multimap
- set：红黑树实现，自动排序，key=value，不允许相同的 key，不能通过迭代器改变元素 的值，insert，erase 不影响迭代器。
- map：红黑树实现，自动排序，元素为 pair，不允许相同 key，key 不可改，value 可改， 迭代器不失效。
- multiset：key 可重复，使用 insert_equal()而不是 insert_unique()

#### 红黑树有什么性质？

1. 每个结点是红色或者黑色。
2. 根结点为黑色。
3. 叶结点为黑色的NULL结点。
4. 如果结点为红，其子节点必须为黑。
5. 任一结点到NULL的任何路径，所含黑结点数必须相同。

- O(log n)



#### map和set的3个问题。

1. 为何map和set的插入删除效率比其他序列容器高。

因为不需要内存拷贝和内存移动

2. 为何map和set每次Insert之后，以前保存的iterator不会失效？

因为插入操作只是结点指针换来换去，结点内存没有改变。而iterator就像指向结点的指针，内存没变，指向内存的指针也不会变。

2. 当数据元素增多时（从10000到20000），map的set的查找速度会怎样变化？

RB-TREE用二分查找法，时间复杂度为logn，所以从10000增到20000时，查找次数从log10000=14次到log20000=15次，多了1次而已。



#### 为何map和set不能像vector一样有个reserve函数来预分配数据？

- map和set内部存储的已经不是元素本身了，而是包含元素的节点。
- 也就是说map内部使用的Alloc并不是map声明的时候从参数中传入的Alloc。例如：`map<int, Alloc > intmap`;
- 这时候在intmap中使用的allocator并不是Alloc, 而是通过了转换的Alloc，具体转换的方法时在内部通过Alloc::rebind重新定义了新的节点分配器，详细的实现参看彻底学习STL中的Allocator。
- 其实你就记住一点，在map和set里面的分配器已经发生了变化，reserve方法你就不要奢望了。

 

## 33. hash table
- 没有自动排序，使用开链法解决冲突，以质数计算桶个数，预先计算好 28 个质 数并存储，需要的时候查找“最接近某数并大于某数”的质数。 
- 插入时可能进行表格重建（元素个数>桶个数，避免单个桶太长），找下一个质数，设立 新的 vector。 
- 对每个旧桶，找出节点落在哪一个新桶里，最后交换新旧 vector，释放旧空间。 

解决冲突的方法： 
- 线性探测 - +1,+1之类
- 二次探测 - 1^2,2^2, 3^2 等等
- 随机探测 - 
- 双重哈希 
- 再哈希 
- 拉链法

- hash_set以hashtable为底层，不具有排序功能，能快速查找。其键值就是实值。（set以RB-TREE为底层，具有排序功能。）
- hash_map以以hashtable为底层，没有自动排序功能，能快速查找，每一个元素同时拥有一个实值和键值。（map以RB-TREE为底层，具有排序功能。）



#### hash_map和map的区别在哪里？

- hash_map底层是散列的所以理论上操作的平均复杂度是常数时间，map底层是红黑树，理论上平均复杂度是O(logn);
这里总结一下:

选用map还是hash_map，关键是看关键字查询操作次数，以及你所需要保证的是查询总体时间还是单个查询的时间。

1. 如果是要很多次操作，要求其整体效率，那么使用hash_map，平均处理时间短。
2. 如果是少数次的操作，使用 hash_map可能造成不确定的O(N)，那么使用平均处理时间相对较慢、单次处理时间恒定的map，考虑整体稳定性应该要高于整体效率，因为前提在操作次数较少。


如果在一次流程中，使用hash_map的少数操作产生一个最坏情况O(N)，那么hash_map的优势也因此丧尽了。












# 【参考资料】
## 主要参考

- [CyC2018](https://github.com/CyC2018/CS-Notes)
- [linw7/Skill-Tree](https://github.com/linw7/Skill-Tree/blob/master/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80C++.md)
- [huihut/interview](https://github.com/huihut/interview)


## 次要参考
- [经典面试题之new和malloc的区别](https://blog.csdn.net/nie19940803/article/details/76358673)
- [C++中的new、operator new与placement new](https://www.cnblogs.com/luxiaoxun/archive/2012/08/10/2631812.html)
- [sizeof与strlen的区别](https://www.cnblogs.com/luori719/p/5218163.html)
- [位域](https://www.cnblogs.com/pure/archive/2013/04/22/3034818.html)

- [C++ 11 左值，右值，左值引用，右值引用，std::move, std::foward](https://blog.csdn.net/xiaolewennofollow/article/details/52559306)